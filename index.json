[{"categories":null,"content":"On a daily basis you have a lot of inputs: you read and listen to things, you talk to people and gather information. You, I, consume a lot, both for work and for pleasure. Less often I, you?, take a pause and elaborate on what I’ve learning. Here, I’ll talk about my experience with a GPU Bootcamp co-organized by Nvidia. ","date":"2021-11-01","objectID":"/2021-11-01/:0:0","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"The BootcampThis bootcamp was organized by the Croatian HPC center and Nvidia on October 28-29, 2021. The format was interesting. In the first morning the speakers provided a preview of OpenMP, OpenACC and CUDA and the students had access to jupyter notebooks to dig deeper in the concepts at their own pace. Interestingly, we were divided into groups based on the programming language of choice to interact with colleagues and brainstorm. The second morning had the best part: a challenge. We received a serial code and in the 3 hours we had to improve its performances. It was guided: it was obvious what part of the code you should focus on, but not how to do it. This part is what I enjoyed the most: discussing with peers on what to do, without restraints. I’ll post here some notes on what we did. It is not a course on OpenACC, OpenMP or something similar. I have decent experience with OpenMP, but it was my first time with OpenACC. I used the translation !$omp into !$acc as a rule of thumb. I assumed, as working hypothesis, that they are quite similar. Follow me in this journey! Spoiler alert ","date":"2021-11-01","objectID":"/2021-11-01/:1:0","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"The serialThe code is a miniapp that performs computational fluid dynamics. Without going in all the details, the code has the main code in cfd.f90 and the routine to perform the step in jacobi.f90. And the makefile, of course. You can imagine the code as the following: initialization; iterations: compute new array from previos iteration, check error, switch the old array with the new computed one; finalization. Let’s see how it behaves. Compiled and run: elapsed time for 500 iterations was 3.717 seconds First, we run the code and profile it with nsys: nsys profile -t nvtx --stats=true --force-overwrite true -o minicfd_serial_profile ./cfd 64 500 The interesting part of the output is in this table: Time(%) Total Time (ns) Instances Average Range ------- --------------- --------- --------------- ----------------- 50.0 3,717,320,116 1 3,717,320,116.0 Overall Iteration 31.6 2,347,212,749 500 4,694,425.5 Jacobi Step 18.3 1,360,728,005 500 2,721,456.0 Switch Array 0.1 5,152,763 500 10,305.5 Calculate Error 0.1 4,892,991 1 4,892,991.0 Initialization 0.0 8,902 1 8,902.0 boundaryPSI and here how it looks on the profiler: The obvious place to start is the Jacobi step: subroutine jacobistep(psinew, psi, m, n) integer :: m, n double precision, dimension(0:m+1, 0:n+1) :: psinew, psi psinew(1:m, 1:n) = 0.25d0*(psi(2:m+1, 1:n) + psi(0:m-1, 1:n) + \u0026 psi(1:m, 2:n+1) + psi(1:m, 0:n-1) ) end subroutine jacobistep ","date":"2021-11-01","objectID":"/2021-11-01/:2:0","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"Unified memory and I-know-better programmmerIn general CPU and GPU have their own memory. Data are stored on the CPU and, if using OpenMP, the programmer has to declare what variables should be allocated also on the device. These data movements might slow down the execution of the code, if the GPU has to wait the host, CPU, and viceversa. To help you deal with data movement, Nvidia (and now Apple? 🤔) makes CPU and GPU see the same memory addresses. In this case what you need to do is just to add the compiler option -ta=tesla:managed. ","date":"2021-11-01","objectID":"/2021-11-01/:3:0","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"Parallel loopTo use OpenACC, we need to rewrite the update with two do-loops and we can add the !$acc directives. subroutine jacobistep_acc(psinew, psi, m, n) integer :: m, n integer :: i, j double precision, dimension(0:m+1, 0:n+1) :: psinew, psi !$acc parallel loop do j=1,n do i=1,m psinew(i, j) = 0.25d0*(psi(2:m+1, 1:n) + psi(0:m-1, 1:n) + \u0026 psi(1:m, 2:n+1) + psi(1:m, 0:n-1) ) !$acc end parallel end subroutine jacobistep_acc We add also the instruction -Minfo=accel -acc -ta=tesla:managed to the Makefile: Minfo=accel, to generate information on optimization for the available accelerator; -acc, to enable the OpenAcc directives; -ta=tesla:managed, to tell the compiler the GPU architecture and whether to use the Unified Memory. We compile and run with nsys profile -t nvtx,openacc,cuda --stats=true --force-overwrite true -o minicfdopenacc_profile ./cfd 64 500 Now the elapsed time is 9.467 seconds (Ouch!) and a summary from the profiling: Time(%) Total Time (ns) Instances Average Range ------- --------------- --------- --------------- ----------------- 50.0 9,466,895,513 1 9,466,895,513.0 Overall Iteration 33.6 6,356,675,349 500 12,713,350.7 Switch Array 16.3 3,090,186,769 500 6,180,373.5 Jacobi Step 0.1 13,560,264 500 27,120.5 Calculate Error 0.0 9,113,720 1 9,113,720.0 Initialization 0.0 8,521 1 8,521.0 boundaryPSI Let’s have a look at the graphical version of the profiler. On top we see the GPU working in light blue/cyan. But there isn’t a continous line. We can see a pattern, each time we are calling the jacobistep_acc. In principle we would like a continous cyan line, i.e. a GPU always working. The limiting factor, though, is the extensive communication between host (CPU) and device (GPU). A closer look at the Jacobi step, show that data are transferred to the Device during the computation. At the end of the step the data are moved back to the host. For all the 500 iterations. ","date":"2021-11-01","objectID":"/2021-11-01/:3:1","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"(copy) In and outAt this point, during the bootcamp, we thought: We know better. We can tell the compiler when and what data we need! We can use !$acc data copy(psi(0:m+1, 0:n+1)) create(psi_tmp(0:n+1, 0:m+1)) and the closing directive !$acc end data to define a data region in which call jacobistep_acc(...) occurs. We need to remove the managed option from the compiler flags, since we-know-better. At this point the code is basically the same as the previous iteration. To improve the data management, we can then put the data region outside the main loop (defined in step 2.). We need to check where the arrays psi and psitmp are used: in computing the error with a function called deltasq; in switching the new array with old one. The error function and the switching can be rewritten as two do-loops, since both were using the vectorized syntax, and we can use the directives seen for the Jacobi step. As a good measure we use the clause collapse(2) in the !$acc parallel loop directive to merge the double loop. Let’s run it: elapsed time for 500 iterations was 0.3524 seconds. The profiler tells us something interesting. Most of the GPU time is spent in the kernels, i.e. in the computation we asked it to accelerate. The data movements occur only at the beginning, green lines, with host to device communications, and at the end of the iterations, from the device to the host. A zoom in the cyan region shows the pattern we had before, but now, there is no bottleneck in the exchange of the data. And this conclude what I learned during the bootcamp. There are other few things, like the !$acc routine, but I haven’t explored yet. ","date":"2021-11-01","objectID":"/2021-11-01/:3:2","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"Conclusi… or not?Writing this post I had a question. What if I use the managed memory approach also in the Switch array? So, I just used the previously defined jacobistep_acc, the explicit loop for the switch, surrounded by the parallel loop region, as shown here: call nvtxStartRange(\"Switch Array\") !$acc parallel loop do j=1,n do i=1,m psi(i, j) = psitmp(i, j) end do end do !$acc end parallel Nothing more. No data region, no other check whether an array is used or not. (We had some bugs before reaching the 0.35 seconds 😅) This approach is too simple. It will work, but it will not be great… Elapsed time for 500 iterations was 0.1584 seconds. So, with the unified memory approach that can be exploited with OpenACC, you can obtain significant improvement in performances. With the custom data management, we gained a factor 10 (3.717/0.352) in speedup. With the unified memory, and fewer lines of code we got a factor of 23!!!!!! ","date":"2021-11-01","objectID":"/2021-11-01/:3:3","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"The EndThe experience has been super nice. I learned a lot from my teammates. It is enough to be an expert, but it is sufficient to start my journey in the OpenACC world. Usually people don’t need a step-by-step guide for all the journey, but indications at the beginning of their path. They will not get lost or discouraged while inexperienced; later they’ll figure things out on their own. #tantecarecose ","date":"2021-11-01","objectID":"/2021-11-01/:4:0","tags":["hugo"],"title":"OpenACC","uri":"/2021-11-01/"},{"categories":null,"content":"While you code, you should comment and document what you are doing. Boring, isn’t is? But it actually helps a future developer, usually you after three days, to understand what you did and to start modifying and integrating your script. So, dear future me, this is How I Built Your Blog! ","date":"2021-07-19","objectID":"/2021-07-19/:0:0","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"OverviewIn a previous post I described my thought process while choosing the framework for the website. Now, let’s understand the basics of a hugo website, so we can start blogging right away! The folder structure of a blank Hugo project looks like this: blog_bubu/ ├── archetypes/ │ └── default.md ├── config.toml ├── content/ │ ├── post1.md │ └── post2.md ├── data/ ├── layouts/ ├── public/ ├── static/ └── themes/ config.toml is the brain of the blog, where we will set the title of the website, enable the features we want to use, our social URLs and so on; content is the folder that will contain the posts or pages we write in Markdown, and that will be rendered in HTML; themes is the folder in which we will download the theme we like, or you can create a completely custom theme with time and knowledge available; layouts is a folder used to override the files used in the theme previously picked. Like in Jekyll, you have your (my) maybe-it-can-work customization away from a working theme, and you can go back simply deleting its content. public is the folder with the rendered HTML files. There is a ton more about Hugo that you can find in the documentation), but I am a huge fan of Pareto principle: 80% consequences from 20% causes. I used to read too much the documentation of software I needed to use, but I realized I often lost the focus on what was important: using the software rather than knowing the software. So, my new mantra while approaching new things is to have a mental framework on how things are supposed to work, learn the (not-so-)bare minimum of what is necessary and start doing. Once I need more advanced features, I go back to the documentation and improve/modify my previous knowledge. This is particularly true in this project: I want a functional blog, without super-fancy things. But, as you will see later, I decided to add functionalities that required a bit of search. The last piece of theoretical framework we need is how to organize our workspace. We will need two repositories: our main folder blog_bubu with drafts and configs, and the public folder as a separate submodule. Including the repository of the theme, we will keep track of these three folders: blog_bubu/ # our main folder called MAIN_REPO │ .. ├── public/ # our submodule called PUBLIC_REPO └── themes/ # external submodule THEME_REPO Now, let’s build our first MVB, Minimum Viable Blog! And if you want to follow along, go and find a theme you like. It might take more than you expect! 😉 ","date":"2021-07-19","objectID":"/2021-07-19/:1:0","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Minimum Viable Blog","date":"2021-07-19","objectID":"/2021-07-19/:2:0","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Set upLet’s remind ourselves the goal: a blog hosted on GitHub Pages https://\u003cyourGitHubUsername\u003e.github.io and see the list of what we need: An empty private GitHub repository for blog_bubu Public repository \u003cyourGitHubUsername\u003e.github.io with at least 1 commit like an empty README.md (to add it as submodule, not need for GitLab) A theme, in my case uBlogger. The features I like of this theme are Light/Dark mode Search Bar Minimal design The go language installed on you local machine The hugo framework Something we want to share (and the time to write it 🤦) I assume that you had no problem in completing the first three tasks. Now let’s install go and hugo. For my operating system, an Ubuntu-like distro, the commands are pretty easy sudo apt install go-golang ## Uncomment the following line if you don't have HomeBrew installed: # /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" brew install hugo For more information about HomeBrew for Linux, you can find here the documentation. Tasks completed! ","date":"2021-07-19","objectID":"/2021-07-19/:2:1","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Creating the blogNow that everything is ready, let’s build the actual blog. First we need to create our main folder: hugo new site \u003csite_folder\u003e Inside \u003csite_folder\u003e you should find the following structure: . ├── archetypes/ │ └── default.md ├── config.toml ├── content/ ├── data/ ├── layouts/ ├── static/ └── themes/ Now let’s link our private repository with the remote repository: # we are inside \u003csite_folder\u003e git init git remote add origin \u003cMAIN_REPO\u003e.git git add . git commit -m \"initialized repo\" git push -u origin master We add the theme now, in my case: git submodule add https://github.com/upagge/uBlogger.git themes/uBlogger and finally, we can render our website with hugo server -D and check the output in a browser at the address localhost:1313. At the moment it is empty. We need to add at least two more things: Edit the config.toml Add a new post For the configuration file I started with the theoretical minimum: baseURL = \"https://\u003cYOUR_USERNAME\u003e.github.io\" # [en, zh-cn, fr, ...] determines default content language defaultContentLanguage = \"en\" # language code languageCode = \"en\" title = \"Blog Bubu\" # Change the default theme to be use when building the site with Hugo theme = \"uBlogger\" [params] # uBlogger theme version version = \"2.0.X\" [menu] [[menu.main]] identifier = \"posts\" # you can add extra information before the name (HTML format is supported), such as icons pre = \"\" # you can add extra information after the name (HTML format is supported), such as icons post = \"\" name = \"Posts\" url = \"/posts/\" # title will be shown when you hover on this menu link title = \"\" weight = 1 [[menu.main]] identifier = \"about\" pre = \"\" post = \"\" name = \"About\" url = \"/About/\" title = \"\" weight = 2 # Markup related configuration in Hugo [markup] # Syntax Highlighting (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false is a necessary configuration noClasses = false For the new post, you can use: hugo new posts/test.md that will create a file .md in content/posts/ named test.md with this content: --- title: \"Lol\" date: 2021-06-28T22:18:01+02:00 draft: true --- Of course, you can create the same file in any other way and it works just fine. You add your content and the you are ready to publish it on GitHub. How? First you add the PUBLIC_REPO as submodule: git submodule add -b main \u003cPUBLIC_REPO\u003e.git public (I am assuming that the repo bubu.github.io has as protected branch main and not master and has at least 1 commit). Once also this repo is set up, Ryan Schachte has the solution for deploying the website: #!/bin/sh # If a command fails then the deploy stops set -e printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" # Build the project. hugo -t uBlogger # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\"rebuilding site $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. git push origin main But, J.! You are following the quickstart guide from XYZ… You are right, Young Padawan! In fact the linear part stops here! ","date":"2021-07-19","objectID":"/2021-07-19/:2:2","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Not-so-minimal blogOnce I got familiar with the structure of the blog, I decided to add some features: the social banner on the homepage, like in the demo a search bar; a header image for each post; and a comment section. So, to start with something already working, I used the config.toml file already provided with the theme in the exampleSite/ folder. ","date":"2021-07-19","objectID":"/2021-07-19/:3:0","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"First changesIn the first few lines I changed the url and the title of the blog. I set the enabelGitInfo = false And, as I said, I wanted the social banner: so I added the username of the various social platform I have in the section of the configuration file [languages.en.social.params] So far so good. ","date":"2021-07-19","objectID":"/2021-07-19/:3:1","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Search barThis theme comes with the support of two search engines (kind of). Lunr, offline and based on a json file you create with hugo -t uBlogger; and Algolia, which is still unclear to me what is. Guess what I opted for… As a remainder for myself, you need this part of the config.toml to generate the json: [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] ","date":"2021-07-19","objectID":"/2021-07-19/:3:2","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"The (Bruce) BannerFollowing the Pareto principle, I had a look at the folder structure of the example site. The posts with the banner have the following structure: in content/posts/ you create a new folder 2021-07-05 where you put a markdown file index.md. You can do that in Bash or with: hugo new posts/2021-07-05/index.md The index.md file has the following preamble: --- title: \"Blogging with Hugo\" date: 2021-07-05T12:10:04+02:00 tags: - \"hugo\" - \"how to\" resources: - name: \"featured-image\" src: \"name_image.png\" --- ","date":"2021-07-19","objectID":"/2021-07-19/:3:3","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Descending orderSomething that didn’t come up until I tried to write this post: the posts in the homepage were in ascending order… My face was more reddish than Mr. John Bercow! I guess it is because this posts are actually pages for hugo. In any case, the solution was quite easy at the end. We can exploit the overriding feature of the layouts folder. I just copied the index.html file from the theme with cp theme/uBlogger/layout/index.html layouts/index.html and added the .Reverse instruction to the range $pages.Pages in the {{- /* Posts */ -}} section: {{- range $pages.Pages.Reverse -}} Important EDITAfter publishing this post I realised I made a mistake. By default, hugo orders posts in descending order, but it has to know that your page is actually a post. To do so, in the header of the post you add: --- weight: 1 title: .... since weight = 1 is what you set in the config.toml. Of course, you have to undo the addition of .Reverse. ","date":"2021-07-19","objectID":"/2021-07-19/:3:4","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"CommentsThe last thing that I wanted for a functional blog was having comments. I wasn’t sold to Disquis, because in its dashboard I couldn’t see the comments. Not sure if it is related to using a static website with hugo, or my free plan. I decided to use Telegram. The config.toml already has the option to handle comments with Telegram, so I just added my User-ID. ","date":"2021-07-19","objectID":"/2021-07-19/:3:5","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"(Not so) minor tweaksAt this point the blog works. I like how it looks, and it seems easy to mantain. So, we are ok, right? NO. What’s wrong with line numbers?!I don’t like the uBlogger way of highligting codes. Why aren’t line numbers aligned???? Easy fix in the config.toml [markup.highlight] codeFences = true guessSyntax = true lineNos = false lineNumbersInTable = true noClasses = false And here’s the difference: Left uBlogger/right Free2dots Tabs, tabs everywhere…One thing I noticed while testing my blog was quite annoying. Each time I clicked on a post, a new tab opened. Now, my muscle memory does not appreciate this feature: I want to go back to the previous page with my mouse or shortcuts, and, if I am on a new tab, I don’t have a previous page. Moreover I plan to add several posts here. Imagine looking for something, and each time a new tab… After a bit of JFGI (see this old post for reference), here’s the solution: cp theme/uBlogger/layouts/summary.html layouts/summary.html and remove the target=\"_blank\", which enables the opening of a new tab. ","date":"2021-07-19","objectID":"/2021-07-19/:3:6","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Getting posts doneEverything is set up. But the difficult part starts now. Writing this post took ages, but I really enjoyed it. I have also a lot of ideas and things I like I want to share. The system is to write two posts per month. It seams reasonable for a person who usually doesn’t like writing. So, let’s see in the next post! #tantecarecose ","date":"2021-07-19","objectID":"/2021-07-19/:4:0","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Bonus track: GitLab versionIn order to host a hugo website on GitLab, you don’t need the public folder as a submodule. You add the .gitlab-ci.yml file in your main repository, with the following content: image:registry.gitlab.com/pages/hugo:latestvariables:GIT_SUBMODULE_STRATEGY:recursivepages:script:- hugoartifacts:paths:- publiconly:- masterOnce you push a new commit, GitLab will launch a job that will create the blog and post it online. The building time is negligible with respect to the Jekyll version. ","date":"2021-07-19","objectID":"/2021-07-19/:5:0","tags":["hugo","how to"],"title":"Blogging with Hugo","uri":"/2021-07-19/"},{"categories":null,"content":"Welcome to the new iteration of my blog! “Wait, what?! Does it mean there are other versions of this thing?” I am glad you are so interested, dear reader! “Not really… But, please, continue…” In 2018 I started my first website as a way to store and present the materials for the practical lessons I was teaching at my university. I needed something pleasing for the eye, but not so fancy. I had 0 expertise in HTML and JavaScript, and paying something was not an option worth considering at that time. I resorted to the RTFM approach in the era of Internet, JFGI. One possible (free) option was to use a static site generator and to host the actual site on GitHub. There I was, using Jekyll for my static website, with some CSS custom modifications. The university course ended, and so the posting of new tutorials. No modifications since then. At the end of 2020, I decided to start publishing content there and change the theme, but it was a bit painful. I thought it was muuuuch easier! (I had to reinstall Ruby, other dependecies, fix outdated versions of some packages, etc…) So I decided to switch to HUGO and here we are. ","date":"2021-06-16","objectID":"/2021-06-16/:0:0","tags":["hugo"],"title":"Dr. Jekyll and Mr. Hugo","uri":"/2021-06-16/"},{"categories":null,"content":"1 What is HUGO?If I ask Google, this is what I get first: the Hugo Spritz, a cocktail. And the writer, Victor Hugo, comes second!!! O tempora, o mores! What I actually wanted is this: a framework for building websites. It is written in Go, a language I know nothing about (as I had no clue for Jekyll written in Ruby). At the moment, the workflow for building this website with Hugo looks quite straightforward: create a new post render it with hugo serve -D if it is ok, you create the html version with hugo -t \u003cyour_theme\u003e you publish it as it is on the platform of your choice. but I will leave the details of the workflow for another post. You might ask: “Dude, that’s the same workflow for Jekyll! Stop being a fanboy!” Well, yes and no. Let’s see why. ","date":"2021-06-16","objectID":"/2021-06-16/:1:0","tags":["hugo"],"title":"Dr. Jekyll and Mr. Hugo","uri":"/2021-06-16/"},{"categories":null,"content":"2 Why did I change?First, I still use Jekyll while handling the backend of another blog (by the way, if you are keen on novels and books, check frittomisto’s blog. It’s interesting, I promise!). But, for my personal site, I switched. Here the key differences I found in this short time: While installing Jekyll, I always ran into some annoyances. With Hugo, I have just installed go and hugo itself with two command lines and I am good to go (no pun intended, lol). For Jekyll I have to write a GitHub Actions to deploy the website, or something similar. For sure, you have the templates available, but if something can go wrong, it usually does. To deploy now, I just have to push the folder with the build. The remote server has to build a container, install the necessary packages and build the site. And it takes some minutes, even for small website. The changes are almost instantaneous. Of course, I found these differences once I started searching info for this new blog. “Ok, I see. But why TWO blogs?!?!” Uhm. Honestly, I did not like the theme I chose with Jekyll, and I was not convinced by other free themes. At the same time, I wanted to preserve the tutorial part of the blog, but not to modify another CSS file in the new version. I started playing around with Hugo, and I kinda like it. I found a lot (probably too many) themes I could choose from, and someone with a switchable dark and light theme. At that point I was sold. Moreover, I decided to be consistent with my presence online as Free2Dots, since I started streaming on Twitch and someday make some videos on Youtube. At the end of the day, I wanted a change. So, let’s change, then. Shall we? #tantecarecose ","date":"2021-06-16","objectID":"/2021-06-16/:2:0","tags":["hugo"],"title":"Dr. Jekyll and Mr. Hugo","uri":"/2021-06-16/"},{"categories":null,"content":"From time to time new ideas pop out in my mind. Things to read, things to do, things to learn. And usually I do not follow up. But I want to. To overcome the intrinsic procrastination that is generated by inertia, a common strategy is to be held accountable by a friend or colleague. Or a personal trainer if you want to consistently exercise. In this case I want to be held accountable by myself, but having more eyes on my behaviour will not hurt. 😅 I will add and remove (once completed) items on the list. Come back here in a while! Let’s show publicly, then, what I want to do and let’s build accountability. ","date":"2021-10-21","objectID":"/projects/:0:0","tags":null,"title":"Wishlist","uri":"/projects/"},{"categories":null,"content":"The Wish-List Latest update: October, 22nd 2021. So, here it is a list of topics I will cover (not in order): create an Electron app; make a simpler clone of VMD using Electron; learn the basics of CMake; learn how quantum computers work; quantum computer emulator in julia; participate in a kaggle challenge; learn the basics of OpenACC and/or CUDA. #TanteCareCose ","date":"2021-10-21","objectID":"/projects/:0:1","tags":null,"title":"Wishlist","uri":"/projects/"},{"categories":null,"content":"Hi, it’s Gianfranco, aka J., here! I have a PhD in Computational Biophysics, a fancy name to say that I used computers to investigate how proteins move and work. “What is a protein?” you may ask. Well, in a nutshell a protein is a small machine inside your body that allows you to walk, see and do everything you do. You can have a brief intro to proteins, from a computational perspective, in the QCB section. It was meant to be a practical section for a course at the University of Trento. But if you have any question, you can contact me via email ;). As far as I am concerned, I developed an interest in programming during my master’s degree, and a fortiori in my PhD years. Therefore, this is what you will find in this blog: posts about programming, mainly from a scientific perspective; posts about interesting, at least for me, books (non-fiction!); what I would like to share! Thanks for passing by, and #TanteCareCose (best wishes!). ","date":"2021-06-08","objectID":"/about/:0:0","tags":null,"title":"About Free2Dots","uri":"/about/"}]